# 前端基础面试题

对于做不完的题目，要学会从题目看到**对应的知识点**，然后学习相关的知识点。



## JD 分析

1. 从 JD 中分析大致的工作内容、技术栈，**存在 JQuery 可能是要维护老项目，如果要求抗压能力可能是要加班**
2. **不要太较真工作经验**（例如要求 3 年工作经验，只有 2 年半也可以去尝试），只是一个大概的范围，如果是 5 年工作经验的（3、4 年的也都可以去尝试，1年去尝试胜任概率不是很高），**也可以根据年限和薪资来判断**，例如（3 年以上经验，只给 10K），基本上是存在虚数（1、2、3 年都可以去，不要被 3 年吓到）
3. **不要过于在意 JD**，因为 JD 大多数是 HR 写的，可能是从别处复制，**不要完全相信 JD 的要求**，如果有些技术栈短时间满足不了的，可以大胆去尝试面试
4. **薪资范围一般情况下看最小数**，例如（10K - 18K），基本上就是 10K 作为基线
5. 社招不用太过度在意学历，可以尝试去投一投



## 准备简历

要包含以下内容：

1. 个人信息：**姓名、性别、电话、邮箱、籍贯（可选）、年龄（可选，用人单位可以从教育经历评估出来）**

2. 工作经历：公司、岗位、岗位职责（可选）、入职时间、离职时间（**有空窗期如实写明即可**）

3. 教育经历：学校、专业、入学和毕业时间（**写最高学历即可**）

4. 项目经历：项目描述、技术栈、个人角色（根据工作时间长短写 2 ~ 4 个**具有说服力的项目，不要写太多项目，可以写别人的项目，前提是自己可以自圆其说**）

5. 专业技能：表现出自己的核心竞争力（**满足用人单位要求，3 ~ 5 条即可，太基础的不要写，例如会使用 vscode**）

6. 播客和开源项目（可选）：**不可临时抱佛脚**

**⚠️ 注意：**

- **界面白纸黑字即可，不要太花哨**
- **注意用词，“精通”、“熟练” 等慎用**
- **项目经历不要造假，可能会被公司拉入黑名单中**



## 面试准备

- 看 JD，判断是否需要临时准备一下
- 打印纸质简历，带着纸和笔（可选）
- 带着自己的电脑，现场可能手写代码（可选）
- **要有时间观念，不要迟到，如果要推迟需要提前说**
- 衣着适当，不用正装，也不要太随意
- 问到为何离职，**不要吐槽前东家，说自己的原因**
- 如果问到加班，基本上就说能
- **不要挑战面试官，即便他错了**
- **遇到不会的问题，也要表现出自己积极的一面**，不要直接说我不会，最好思考一两分钟，问一下面试官能不能给个引导，实在想不出来可以放弃，**但需要问一下面试官这个问题的答案，或者说自己回去再研究一下，承认是自己知识的一个盲区**

更多内容可以参考：https://www.imooc.com/article/300475



## HTML

### 如何理解语义化？

1. 让人更容易读懂代码，增加代码可读性
2. 让搜索引擎更容易读懂（SEO 优化）

例如 `<h1>` 标签中的中的内容通常是比较重要的。



### 默认情况下，哪些 HTML 标签是块状元素，哪些是内联元素？

- 块状元素：`display: block/table`，独占一行，有 `div`、`h1~h6`、`p`、`table`、`ul`、`ol` 等
- 内联元素：`display: inline/inline-block`，不会独占一行，直到浏览器的边缘自动换行，有 `span`、`img`、`input`、`button` 等



## CSS

### 盒子模型的宽度如何计算？

```html
<!-- 请问 div1 的 offsetWidth 是多大？ -->
<style>
  #div1 {
    width: 100px;
    padding: 10px;
    border: 1px solid #ccc;
    margin: 10px;
  }
</style>
```

- **`offsetWidth` = （内容宽度 + 内边距 + 边框），没有外边距，所以为 `122px`**

如果要让 `offsetWidth = 100px`，可以使用 `box-sizing: border-box`。



### `margin` 纵向重叠的问题

```html
<!-- AAA 和 BBB 之间的距离是多少？ -->
<style>
  p {
    font-size: 16px;
    line-height: 1;
    margin-top: 10px;
    margin-bottom: 15px;
  }
</style>

<p>AAA</p>
<p></p>
<p></p>
<p></p>
<p>BBB</p>
```

它们两者之间的距离为 `15px`，**垂直方向的外边距重叠，空的 `<p>` 标签也会重叠，优先使用大的外边距**。



### `margin` 负值的问题

- `margin-top` 和 `margin-left` 负值元素会向上、向左移动
- `margin-right` 负值，**元素自身不受影响，右侧元素左移**
- `margin-bottom` 负值，**元素自身不受影响，下方元素上移**



### BFC 的理解和运用

BFC 全称 Block Format Context，**块级格式化上下文**。

- **是一个独立的渲染区域，内部元素的渲染不会影响边界以外的元素**
- 区域的高度计算会包含内部浮动元素的高度，所以可以用来清除浮动

如何创建 BFC：

- **`overflow` 不为 `visible` 的块级元素**
- **`float` 不为 `none`**
- **`display` 为`flex`、`inline-block`、`grid` 的元素**
- **`position` 为 `absolute` 或 `fixed` 的元素**



### 如何实现圣杯布局和双飞翼布局

两者的实现目的：

1. **三栏布局，中间一栏最先加载和渲染（内容最重要）**
2. **两侧内容宽度固定，中间内容宽度自适应**
3. **一般用于 PC 网页**

- 圣杯布局实现

  ```html
  <style>
    body {
      min-width: 550px;
    }
  
    #header {
      text-align: center;
      background-color: #f1f1f1;
    }
  
    .container {
      /* 为容器添加内边距为左右两侧内容提前占位 */
      padding-left: 200px;
      padding-right: 150px;
    }
  
    .container .cloumn {
      /* 使用 float 布局 */
      float: left;
    }
  
    #footer {
      clear: both;
      text-align: center;
      background-color: #f1f1f1;
    }
  
    #center {
      background-color: #cccf;
      width: 100%;
    }
  
    #left {
      background-color: yellow;
      width: 200px;
      /* 向左移动整个容器宽度，与 center 容器左边边框对齐 */
      margin-left: -100%;
      /* 使用相对定位，将自身向左偏移 200px */
      position: relative;
      right: 200px;
    }
  
    #right {
      background-color: red;
      width: 150px;
      /* margin-right 负值，在外界看来自身没有宽度，所以就不会再换行，浮动到容器的右侧 */
      margin-right: -150px;
    }
  </style>
  
  <div id="header">this is header</div>
  <div class="container">
    <!-- 中间容器优先渲染 -->
    <div id="center" class="cloumn">this is center</div>
    <div id="left" class="cloumn">this is left</div>
    <div id="right" class="cloumn">this is right</div>
  </div>
  <div id="footer">this is footer</div>
  ```

- 双飞翼布局

  ```html
  <style>
    body {
      min-width: 550px;
    }
  
    .col {
      float: left;
    }
  
    #main {
      width: 100%;
      height: 200px;
      background-color: #ccc;
    }
  
    #main-wrap {
      margin: 0 190px;
    }
  
    #left {
      width: 190px;
      height: 200px;
      background-color: #0000ff;
      margin-left: -100%;
    }
  
    #right {
      width: 190px;
      height: 200px;
      background-color: #ff0000;
      margin-left: -190px;
    }
  </style>
  
  <!-- 中间容器优先渲染，比圣杯布局多嵌套了一层 -->
  <div id="main" class="col">
    <div id="main-wrap">this is main</div>
  </div>
  <div id="left" class="col">this is left</div>
  <div id="right" class="col">this is right</div>
  ```



### 手写 `clearfix`

```css
.clearfix::after {
  content: '';
  /* 对 IE6/7/8 以及老旧浏览器来说，table 的清浮动效果比 block 更可靠 */
  display: table;
  /* 元素被向下移动以清除左右浮动 */
  clear: both;
}
.clearfix {
  zoom: 1; /* 兼容 IE 低版本 */
}
```



### 使用 `flex` 画骰子

```html
<style>
  .box {
    display: flex;
    justify-content: space-between;
    width: 150px;
    height: 150px;
    border: 2px solid #000;
    padding: 15px;
    box-sizing: border-box;
  }

  .item {
    background-color: #000;
    width: 15px;
    height: 15px;
    border-radius: 50%;
  }

  .item:nth-child(2) {
    align-self: center;
  }
  .item:nth-child(3) {
    align-self: flex-end;
  }
</style>

<div class="box">
  <div class="item"></div>
  <div class="item"></div>
  <div class="item"></div>
</div>
```



### `absolute` 和 `relative` 分别依据什么定位？

- **`relative` 依据自身定位**，不会影响外界元素
- **`absolute` 依据最近一层的定位元素定位**

定位元素有 `absolute`、`relative`、`fixed`，如果这些都没找到，就会找到最外层的 `body`。



### 居中对齐有哪些实现方式？

- 水平居中

  - `inline/inline-block` 元素可以**在其父元素上使用 `text-align: center` 实现水平居中**
  - `block` 元素可以**使用 `margin: 0 auto` 在其自身上实现水平居中**
  - `absolute` 元素可以**使用 `left: 50%` + `margin-left: 自身宽度一半的负值`**
  - `absolute` 元素可以**使用 `left: 50%` + `transform: translateX(-50%)`**

- 垂直居中

  - `inline/inline-block` 元素可以**在其父元素上设置 `line-height` 的值等于 `height` 的值来实现垂直居中**
  - `absolute` 元素可以**使用 `top: 50%` + `margin-top: 自身高度一半的负值`**
  - `absolute` 元素可以**使用 `top: 50%` + `transform: translateY(-50%)`**
  - `absolute` 元素可以**使用 `top`、`left`、`bottom`、`right` 都为 `0` + `margin: 0 auto` 来实现**

  

### `line-height` 的继承问题

```html
<!-- p 标签的行高将会是多少？ -->
<style>
  body {
    font-size: 20px;
    line-height: 200%;
  }
  p {
    font-size: 16px;
  }
</style>

<p>AAA</p>
```

`p` 标签的行高将会是 `40px`

`line-height` 继承规则：

- 如果父元素上的 `line-height` 写了具体值，例如 `30px`，则子元素直接继承该值
- 如果父元素上的 `line-height` 写了比例，例如 `2` 或 ` 1.5`，则子元素直接继承该比例，最终值根据子元素的 `font-size` 值进行计算
- **如果父元素上的 `line-height` 写了百分比，例如 `200%`，则继承父元素的 `font-size` 和 `line-height` 百分比最终计算出来的值**



### `rem` 是什么？

`rem` 是一个长度单位，还有其它的长度单位：

- `px`，绝对长度单位，最常用
- `em`，相对长度单位，相对于父元素，不常用
- **`rem`，相对长度单位，相对于根元素，常用用于响应式布局**



### 如何实现响应式？

**rem 方案**

- 通过 JS 或者媒体查询，根据不同的屏幕宽度调整根元素的 `font-size`
- 然后使用 `rem` 单位来进行布局

`rem` 方案存在以下缺点：

1. **使用媒体查询实现存在适应阶梯性**，例如想在 375、376 宽度的屏幕下显示都有所不同，只适用于跨度大的场景
2. 如果使用 JS 实现则可以避免适应阶梯性问题，但**需要依赖 JS**



**vw/vh 方案**

- `vh` 网页视口高度的 `1 / 100`
- `vw` 网页视口宽度的 `1 / 100`
- `vmax`：取两者的最大值
- `vmin`：取两者的最小值

使用 `vw` 或者 `vh` 单位进行网页布局，**可以避免适应阶梯性，也不依赖 JS**。

**缺点：存在兼容问题，低版本浏览器不支持**。



## JavaScript

### `typeof` 能判断哪些类型

- **可以识别除了 `null` 以外的基本类型**
- **可以识别 `function` 类型**



### 何时使用 `===` 何时使用 `==`

 **除了以下这种情况外，其它地方一律使用 `===`：**

  ```js
  const obj = { x: 100 }
  if(obj.a == null) {}
  
  // 相当于
  // if(obj.a === null || obj.a === undefined) {}
  ```

常见的类型转换：

- 字符串拼接

  ```js
  const a = 100 + 10 // 110
  const b = 100 + '10' // '10010'
  const c= true + '10' 'true10'
  ```

- `==` 运算符

  ```js
  100 == '100' // true
  0 == '' // true
  0 == false // true
  false == '' // true
  null == undefined // true
  ```

- `if` 语句和逻辑运算

  ```js
  // 以下是 falsely 变量，除此之外都是 truly 变量
  !!0 === false
  !!NaN === false
  !!'' === false
  !!null === false
  !!undefined === false
  !!false == false
  ```

  

### 值类型和引用类型的区别

- 值类型

  ```js
  let a = 100
  let b = a
  a = 200
  console.log(b) // 100
  ```

  **值类型的值通常存在栈中**。

- 引用类型

  ```js
  let a = { age: 20 }
  let b = a
  b.age = 21
  console.log(a.age) // 21
  ```

  **引用类型的对象存在堆中，变量本身在栈中保存对堆对象的引用**。

之所以这样设计，是因为值类型的占用通常都比较小，而引用类型占用可能会很大，直接将对象赋值给变量速度可能会很慢，所以引用类型是在变量中存储的是对堆对象的引用而非对象本身。

**常见的值类型：`number`、`string`、`boolean`、`symbol`、`null`、`undefined`、`bigint`**

**常见的引用类型：`object`、`array`、`function`**



### 手写深拷贝

```js
function deepClone(obj = {}, map = new WeakMap()) {
  // 判断传入的值是否是对象类型，如果不是则直接返回
  if(typeof obj !== 'object' || obj === null) return obj
  
  // 避免循环引用
  if(map.has(obj)) return map.get(obj)
  
  // 判断传入的值是否是数组并初始化结果
  let result = Array.isArray(obj) ? [] : {}
  map.set(obj, result)
  
  
  for(let key in obj) {
    // 排除原型对象上的key
    if(obj.hasOwnProperty(key)) {
      result[key] = deepClone(obj[key], map)
    }
  }
 
  return result
}
```



### 如何准确判断一个变量是不是数组

有以下三种方式可以判断：

```js
a instanceof Array
Array.prototype.isPrototypeOf(a)
({}).toString.call(a) === '[object Array]'
```



### 手写一个简易的 jQuery，考虑插件和扩展性

```js
class jQuery {
  constructor(selector) {
    // 根据传入的选择器获取 DOM
    const result = document.querySelectorAll(selector)

    // 将 DOM 存储在实例上
    const length = result.length
    for (let i = 0; i < length; i++) {
      this[i] = result[i]
    }
    // 并记录长度（类数组）
    this.length = length
    // 记录选择器
    this.selector = selector
  }

  /** 获取指定下标的 DOM 元素
   * @param {number} index 下标
   */
  get(index) {
    return this[index]
  }
  /** 变量 DOM 元素
   * @param {function} callback 回调函数
   */
  each(callback) {
    for (let i = 0; i < this.length; i++) {
      const elem = this[i]
      // 在回调中返回对应的元素
      callback(elem)
    }
  }
  /** 监听方法
   * @param {string} type 方法类型
   * @param {function} callback 回调函数
   */
  on(type, callback) {
    // 遍历元素，为每个元素绑定方法
    return this.each((elem) => {
      elem.addEventListener(type, callback, false)
    })
  }
}

// 插件形式扩展
jQuery.prototype.dialog = function (info) {
  alert(info)
}

// 增强
class MyJQuery extends jQuery {
  constructor(selector) {
    super(selector)
  }
  // 扩展自己的方法
  addClass(className) {
    // ...
  }
}
```



### `class` 的原型本质，怎么理解

- 描述或者绘制原型链
- 属性和方法的执行规则



###  `this` 的不同应用场景，如何取值？

- 当做普通函数被调用，`this` 就是 `window`，严格模式下是 `undefined`
- 通过 `call`、`apply`、`bind` 传入的对象作为 `this`
- 作为对象方法调用 `this` 就是对象本身
- 在 `class` 的方法中调用 `this` 是当前实例对象本身
- 箭头函数的 `this` 会找它上级作用域的 `this` 值



### 手写 `bind` 函数

```js
Function.prototype.bind1 = function () {
  // 将参数拆解为数组
  const args = Array.prototype.slice.call(arguments)

  // 获取 this（数组第一项）
  const t = args.shift()

  // 保存 fn1.bind(...) 中的 fn1
  const self = this

  // 返回一个函数
  return function () {
    return self.apply(t, args)
  }
}

function fn1(a, b, c) {
  console.log('this', this)
  console.log(a, b, c)
  return `this is fn1`
}

const fn2 = fn1.bind1({ x: 100 }, 10, 20, 30)
const res = fn2()
console.log(res)
```



### 实际开发中闭包的应用场景，举例说明

闭包：自由变量的查找**是在函数定义的地方，向上级作用域查找，不是在执行的地方**。

可以使用闭包隐藏数据，只提供 API。

```js
function createCache() {
  const data = {} // 闭包中的数据，被隐藏，不被外界访问
  return {
    set: function (key, value) {
      data[key] = value
    },
    get: function (key) {
      return data[key]
    },
  }
}
```



### 如何实现创建 10 个 `<a>` 标签，点击的时候弹出来对应的序号

```js
let a
for (let i = 0; i < 10; i++) {
  a = document.createElement('a')
  a.innerHTML = i + '<br>'
  a.addEventListener('click', function(event) {
    event.preventDefault()
    alert(i)
  })
  document.body.appendChild(a)
}
```

