# 现代 JavaScript 教程笔记
教程地址：https://zh.javascript.info



## 类型转换

- `Number(undefined)` 转换结果为 `NaN`

- `Number(null)` 转换结果为 `0`
- `Number('123z')` 转换结果为 `NaN`
- `Boolean(' ')` 转换结果为 `true`
- `Boolean('')` 转换结果为 `false`
- `Boolean('0')` 转换结果为 `true`
- `Boolean(0)` 转换结果为 `false`
- `String([])` 转换结果为 `''`



## 值的比较

```js
alert( undefined == null); // true
```

`undefined` 与 `null` 进行非严格相等比较时**不会转换为数字**，两者始终相等，这是 JavaScript 的一个特殊规则

以下结果都为 `false`

```js
alert( null == 0); // false
```

```js
alert( undefined == 0); // false
```



## Symbol

使用场景：

- 设置对象的 “隐藏” 属性，例如：给第三方库的对象设置一个隐藏属性，`Symbol` **始终是唯一**的，**不会与对象原有的属性冲突**

  ```js
  const user = {
    name: 'CodePencil',
  };
  
  const id = Symbol('id');
  user[id] = '1';
  
  console.log(user[id]); // '1'
  ```

- 通过修改 `Symbol.*` 来改变一些内建行为，例如：通过修改 `Symbol.toPrimitive` 来改变对象类型转换内建行为



## 数字类型



### 数字表现方式

- `0` 过多时，可以使用 `_` 作为分隔符

  ```js
  let billion = 1000_000_000;
  ```

- 使用 `e` 来缩短数字，`e` 后面跟 0 的个数

  ```js
  let num = 1.9e4; // 等价于 19000
  // 相当于 1.9 * 10000
  ```

- 对于小数，`e` 后面跟小数左侧 0 的个数

  ```js
  let num = 1.23e-6; // 等价于 0.00000123
  // 相当于 1.23 / 1000000
  ```




### 数字精度问题

数字是以 64 位 IEEE-754 表示的，其中 52 位存储数字，11 位用来存储小数点的位置，1 位用于符号

```js
alert( 0.1 + 0.2 === 0.3 ); // false
```

上述代码会出现 `0.1 + 0.2` 不等于 `0.3` 出现了精度的原因：

1. 在计算机中数字是以**二进制**的形式存储在内存中

2. 在十进制系统中，可以确保 10 的整数次幂作为除数时可以正常工作，例如：`1 / 10 = 0.1`，但是如果是 `1 / 3 = 0.333...` 则会出现无法除尽的情况，因为 3 不是 10 的整数次幂

3. 类似的，在二进制系统中，可以确保 **2 整数次幂作为除数时可以正常工作**，在 `0.1 + 0.2` 中，`0.1 === 1 / 10`、`0.2 === 2 / 10` 10 不是 2 整数次幂，所以会出现无限循环的状态

   ```js
   alert( 0.1.toFixed(20) ); // 0.10000000000000000555
   alert( 0.2.toFixed(20) ); // 0.20000000000000001110
   ```

4. IEEE-754 数字格式通过将数字舍入到最接近的可能数字来解决此问题，所以在 `0.1 + 0.2` 进行计算时，**会将它们的 “精度损失” 叠加起来**



解决方案

- 使用 `toFixed(n)` 对结果进行舍入

  ```js
  let sum = 0.1 + 0.2;
  alert( sum.toFixed(1) ); // 0.3
  ```

  **注意：** `toFixed(n)` 返回的结果是个字符串

- 可以将数字乘以 10 临时转换为整数，再进行计算，然后再将结果除回

  ```js
  let sum = (0.1 * 10 + 0.2 * 10) / 10;
  alert( sum ); // 0.3
  ```

  **注意：** 这种方法只能减少误差，但不能避免误差



## 数组

遍历数组的元素

- `for (let i = 0; i < arr.length; i++)` 运行速度最快，兼容旧版本浏览器
- `for (let item of arr)` 现代语法，只能访问值，无法访问键
- `for (let i in arr)` 数组中不要使用这个，因为会输出数组的所有属性，不只是是数字属性



### includes
方法 `includes` 可以正确处理 `NaN`，`indexOf` 无法正确处理 `NaN`

```js
const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1（错误，应该是 0）
alert( arr.includes(NaN) ); // true（正确）
```

### sort
方法 `sort` 默认情况下是**按字符串顺序进行排序**

```js
let arr = [ 1, 2, 15 ];

arr.sort();

alert( arr ); // 1, 15, 2
```

提供函数作为方法 `sort` 的参数

```js
let arr = [ 1, 2, 15 ];

arr.sort( (a, b) => a - b );

alert( arr ); // 1, 2, 15
```

为什么返回 `a - b` 就可以控制排序的顺序？

因为 `sort` 方法通过传入的**比较函数的返回值**来决定两个元素的顺序

- 正值：表示 `a` 应该排在 `b` 后面
- 负值：表示 `a` 应该排在 `b` 前面
- 零：表示两个元素相等，顺序不变