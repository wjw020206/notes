<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
      }

      #field {
        background: url(https://zh.js.cx/task/drag-heroes/solution/field.svg);
        width: 800px;
        height: 500px;
        float: left;
      }

      .hero {
        background: url(https://zh.js.cx/drag-heroes/heroes.png);
        width: 130px;
        height: 128px;
        float: left;
      }

      #hero1 {
        background-position: 0 0;
      }

      #hero2 {
        background-position: 0 -128px;
      }

      #hero3 {
        background-position: -120px 0;
      }

      #hero4 {
        background-position: -125px -128px;
      }

      #hero5 {
        background-position: -248px -128px;
      }

      #hero6 {
        background-position: -244px 0;
      }

      .draggable {
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <h2>将超级英雄放置在足球场周围。</h2>

    <p>
      超级英雄和球都是带有 "draggable" 类的元素。使它们真的可拖动（draggable）。
    </p>

    <p>
      重要：通过窗口限制拖动。如果可拖动的元素被拖到窗口的顶端或末端，则页面应该滚动以让我们进一步拖动它。
    </p>

    <p>
      如果你的屏幕足够大，能够把整个文档都显示出来 ——
      那么请缩小窗口以进行垂直滚动，以便对此进行测试。
    </p>

    <p>
      在此任务中，处理垂直滚动就够了。通常没有水平滚动，并且在需要时可以采用类似的方式进行处理。
    </p>

    <p>
      此外：英雄永远都不会离开页面。如果它们到达了文档的边缘，它们不会被拖动到文档外。
    </p>

    <div id="field"></div>
    <div class="hero draggable" id="hero1"></div>
    <div class="hero draggable" id="hero2"></div>
    <div class="hero draggable" id="hero3"></div>
    <div class="hero draggable" id="hero4"></div>
    <div class="hero draggable" id="hero5"></div>
    <div class="hero draggable" id="hero6"></div>

    <img src="https://en.js.cx/clipart/ball.svg" class="draggable" />
    <div style="clear: both"></div>
    <script>
      document.addEventListener('mousedown', function (event) {
        const draggable = event.target.closest('.draggable');
        if (!draggable) return;

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);

        document.body.style.userSelect = 'none';

        draggable.ondragstart = function () {
          return false;
        };

        const shiftX = event.clientX - draggable.getBoundingClientRect().left;
        const shiftY = event.clientY - draggable.getBoundingClientRect().top;

        draggable.style.position = 'fixed';

        moveAt(event.clientX, event.clientY);

        function moveAt(clientX, clientY) {
          // 新的窗口相对坐标
          let newX = clientX - shiftX;
          let newY = clientY - shiftY;

          // 检查新坐标是否位于窗口底部边缘以下
          let newBottom = newY + draggable.offsetHeight;

          if (newBottom > document.documentElement.clientHeight) {
            const docBottom =
              document.documentElement.getBoundingClientRect().bottom;

            let scrollY = Math.min(docBottom - newBottom, 10);

            if (scrollY < 0) scrollY = 0;

            window.scrollBy(0, scrollY);
            newY = Math.min(
              newY,
              document.documentElement.clientHeight - draggable.offsetHeight
            );
          }

          if (newY < 0) {
            let scrollY = Math.min(-newY, 10);

            if (scrollY < 0) scrollY = 0;

            window.scrollBy(0, -scrollY);
            newY = Math.max(newY, 0);
          }

          let newRight = newX + draggable.offsetWidth;

          if (newRight > document.documentElement.clientWidth) {
            const docRight =
              document.documentElement.getBoundingClientRect().right;

            let scrollX = Math.min(docRight - newRight, 10);

            if (scrollX < 0) scrollX = 0;

            window.scrollBy(scrollX, 0);
            newX = Math.min(
              newX,
              document.documentElement.clientWidth - draggable.offsetWidth
            );
          }

          if (newX < 0) {
            let scrollX = Math.min(-newX, 10);

            if (scrollX < 0) scrollX = 0;
            window.scrollBy(-scrollX, 0);
            newX = Math.max(newX, 0);
          }

          draggable.style.left = newX + 'px';
          draggable.style.top = newY + 'px';
        }

        function onMouseMove(event) {
          moveAt(event.clientX, event.clientY);
        }

        function onMouseUp() {
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
          draggable.style.top =
            parseInt(draggable.style.top) + window.pageYOffset + 'px';
          draggable.style.left =
            parseInt(draggable.style.left) + window.pageXOffset + 'px';
          draggable.style.position = 'absolute';
          document.body.style.userSelect = '';
          draggable.ondragstart = null;
          draggable.style.position = 'absolute';
        }
      });
    </script>
  </body>
</html>
